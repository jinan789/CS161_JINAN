contract ERC20ByMetadropV1 is
  Context,
  ERC20Spendable,
  IERC20ByMetadropV1,
  Ownable,
  TaxAdmin
{
  using EnumerableSet for EnumerableSet.AddressSet;
  using SafeERC20 for IERC20;

  uint256 public constant version = 100010001000000000;
  uint256 internal constant BP_DENOM = 10000;
  uint256 internal constant ROUND_DEC = 100000000000;

  IUniswapV2Locker internal immutable unicryptLocker;
  IUniswapV2Router02 internal immutable uniswapRouter;
  uint256 public immutable lpSupply;
  uint256 public immutable projectSupply;
  uint256 public immutable maxTokensPerTransaction;
  uint256 public immutable maxTokensPerWallet;
  uint256 public immutable maxProjectBuyTaxBasisPoints;
  uint256 public immutable maxProjectSellTaxBasisPoints;
  uint256 public immutable maxMetadropBuyTaxBasisPoints;
  uint256 public immutable maxMetadropSellTaxBasisPoints;
  uint256 public immutable lpLockupInDays;
  address public immutable metadropTreasury;
  address public immutable uniswapV2Pair;
  address internal immutable metadropV1Factory;
  uint256 internal immutable metadropTaxPeriodInDays;
  bool internal immutable tokenHasTax;
  bool internal immutable tokenHasLimits;

  /** @dev {Storage Slot 1} Vars read / written as part of transfers packed to a single
   * slot for warm reads / writes.
   *   Slot 1:
   *      128
   *       32
   *   16 * 5
   *    8 * 2
   *   ------
   *      256
   *   ------ */
  uint128 public projectTaxPendingSwap;
  uint32 public fundedDate;
  uint16 public projectBuyTaxBasisPoints;
  uint16 public projectSellTaxBasisPoints;
  uint16 public metadropBuyTaxBasisPoints;
  uint16 public metadropSellTaxBasisPoints;
  uint16 public swapThresholdBasisPoints;
  /** @dev {autoSwapEnabled} We start with {autoSwapEnabled} OFF, as we don't want to
   * call this when  processing initial liquidity from this address. We turn this on when
   * liquidity has been loaded, and use this bool to control processing during auto-swaps
   * from that point onwards. */
  bool private autoSwapEnabled = false;

  /** @dev {limitsEnabled} Similarly, we don't validate txn limits during liquidity loading. This is
   * automatically set to true when liquidity loading is complete.
   *
   * This can be set back to false by the tax admin. This is a neccesary fallback
   * position where on-chain actions cannot meet the validation and need to occur.
   * For example, someone may stake token into a staking contract over a number
   * of transactions until the staked balance is higher than the per txn limit.
   * If the developer of the staking contract has not considered the per txn
   * limit, and the 'unstake' method simply remits the entire user balance in
   * one txn, then this token would now be trapped in the staking contract. Under
   * these circumstances the limit can be turned off to allow the transaction to
   * proceed.
   *
   * After a given amount of time any successful token will have
   * become distributed such that a per transaction limit is less relevant. */
  bool private limitsEnabled = false;

  /** @dev {Storage Slot 2} Not read in transfers etc:
   *      160
   *   ------
   *      160
   *   ------ */
  address public projectTreasury;

  /** @dev {Storage Slot 3} Only written to if metadrop tax applies, otherwise no writes occur.
   * Note that although a uint128 supply limit applies to this contract we store this
   * as a uint256. As the evm uses uint256 for all vars we save the gas cost of the
   * implicit cast by using uint256, given there are no other vars we can sensibly
   * pack with. For the project tax we pack a uint128 with other vars read and written
   * as part of transfer processing, allowing a warm write.
   *   Slot 3:
   *      256
   *   ------
   *      256
   *   ------ */
  uint256 public metadropTaxPendingSwap;

  /** @dev {Storage Slot 4} Not read as part of transfers etc.
   *    256
   * ------
   *    256
   * ------ */
  uint256 private _totalSupply;

  /** @dev {Storage Slot 5 to n} Not read as part of transfers etc. */
  string private _name;
  string private _symbol;

  /** @dev {Social Links} These shouldn't have _ prefix as they are public, but we want these at the top */
  string public _1___website;
  string public _2___twitter;
  string public _3___telegram;
  string public _4___discord;

  /** @dev {_balances} Addresses balances */
  mapping(address => uint256) private _balances;

  /** @dev {_allowances} Addresses allocance details */
  mapping(address => mapping(address => uint256)) private _allowances;

  /** @dev {_liquidityPools} Enumerable set for liquidity pool addresses */
  EnumerableSet.AddressSet private _liquidityPools;

  /** @dev {_liquidityPools} Enumerable set for addresses where limits do not apply */
  EnumerableSet.AddressSet private _unlimited;

  /**
   * @dev {constructor}
   *
   * @param integrationAddresses_ The project owner, uniswap router and unicrypt locker.
   * @param baseParams_ configuration of this ERC20.
   * @param supplyParams_ Supply configuration of this ERC20.
   * @param taxParams_  Tax configuration of this ERC20
   */
  constructor(
    address[3] memory integrationAddresses_,
    bytes memory baseParams_,
    bytes memory supplyParams_,
    bytes memory taxParams_
  ) {
    _decodeBaseParams(integrationAddresses_[0], baseParams_);
    uniswapRouter = IUniswapV2Router02(integrationAddresses_[1]);
    unicryptLocker = IUniswapV2Locker(integrationAddresses_[2]);

    ERC20SupplyParameters memory supplyParams = abi.decode(
      supplyParams_,
      (ERC20SupplyParameters)
    );

    ERC20TaxParameters memory taxParams = abi.decode(
      taxParams_,
      (ERC20TaxParameters)
    );

    tokenHasLimits = _processSupplyParams(supplyParams);
    projectTreasury = supplyParams.projectTreasury;
    metadropTreasury = supplyParams.metadropTreasury;
    lpSupply = supplyParams.lpSupply * (10 ** decimals());
    projectSupply = supplyParams.projectSupply * (10 ** decimals());
    maxTokensPerWallet = supplyParams.maxTokensPerWallet * (10 ** decimals());
    maxTokensPerTransaction = supplyParams.maxTokensPerTxn * (10 ** decimals());
    lpLockupInDays = supplyParams.lpLockupInDays;

    tokenHasTax = _processTaxParams(taxParams);
    maxProjectBuyTaxBasisPoints = taxParams.maxProjectBuyTaxBasisPoints;
    maxProjectSellTaxBasisPoints = taxParams.maxProjectSellTaxBasisPoints;
    maxMetadropBuyTaxBasisPoints = taxParams.maxMetadropBuyTaxBasisPoints;
    maxMetadropSellTaxBasisPoints = taxParams.maxMetadropSellTaxBasisPoints;
    metadropTaxPeriodInDays = taxParams.metadropTaxPeriodInDays;
    swapThresholdBasisPoints = uint16(taxParams.taxSwapThresholdBasisPoints);

    metadropV1Factory = _msgSender();

    _mintBalances(lpSupply, projectSupply);

    uniswapV2Pair = _createPair();
  }

  /**
   * @dev {onlyOwnerOrFactory}
   *
   * Throws if called by any account other than the owner OR factory.
   */
  modifier onlyOwnerOrFactory() {
    if (metadropV1Factory != _msgSender() && owner() != _msgSender()) {
      _revert(CallerIsNotFactoryOrProjectOwner.selector);
    }
    _;
  }

  /**
   * @dev function {_decodeBaseParams}
   *
   * Decode NFT Parameters
   *
   * @param projectOwner_ The owner of this contract
   * @param encodedBaseParams_ The base params encoded into a bytes array
   */
  function _decodeBaseParams(
    address projectOwner_,
    bytes memory encodedBaseParams_
  ) internal {
    _transferOwnership(projectOwner_);
    _transferTaxAdmin(projectOwner_);

    (
      _name,
      _symbol,
      _1___website,
      _2___twitter,
      _3___telegram,
      _4___discord
    ) = abi.decode(
      encodedBaseParams_,
      (string, string, string, string, string, string)
    );
  }

  /**
   * @dev function {_processSupplyParams}
   *
   * Process provided supply params
   *
   * @param erc20SupplyParameters_ The supply params encoded into a bytes array
   */
  function _processSupplyParams(
    ERC20SupplyParameters memory erc20SupplyParameters_
  ) internal returns (bool tokenHasLimits_) {
    if (
      erc20SupplyParameters_.maxSupply !=
      (erc20SupplyParameters_.lpSupply + erc20SupplyParameters_.projectSupply)
    ) {
      _revert(SupplyTotalMismatch.selector);
    }

    if (erc20SupplyParameters_.maxSupply > type(uint128).max) {
      _revert(MaxSupplyTooHigh.selector);
    }

    if (erc20SupplyParameters_.lpLockupInDays > type(uint96).max) {
      _revert(LPLockUpMustFitUint96.selector);
    }

    _unlimited.add(erc20SupplyParameters_.projectTreasury);
    _unlimited.add(address(this));
    _unlimited.add(address(0));

    if (
      erc20SupplyParameters_.maxTokensPerTxn == 0 &&
      erc20SupplyParameters_.maxTokensPerWallet == 0
    ) {
      return false;
    } else {
      return true;
    }
  }

  /**
   * @dev function {_processTaxParams}
   *
   * Process provided tax params
   *
   * @param erc20TaxParameters_ The tax params encoded into a bytes array
   */
  function _processTaxParams(
    ERC20TaxParameters memory erc20TaxParameters_
  ) internal returns (bool tokenHasTax_) {
    /**
     * @dev We use the immutable var {tokenHasTax} to avoid unneccesary storage writes and reads. If this
     * token does NOT have tax applied then there is no need to store or read these parameters, and we can
     * avoid this simply by checking the immutable var. Pass back the value for this var from this method.
     */
    if (
      erc20TaxParameters_.projectBuyTaxBasisPoints == 0 &&
      erc20TaxParameters_.projectSellTaxBasisPoints == 0 &&
      erc20TaxParameters_.metadropBuyTaxBasisPoints == 0 &&
      erc20TaxParameters_.metadropSellTaxBasisPoints == 0 &&
      erc20TaxParameters_.maxProjectBuyTaxBasisPoints == 0 &&
      erc20TaxParameters_.maxProjectSellTaxBasisPoints == 0 &&
      erc20TaxParameters_.maxMetadropBuyTaxBasisPoints == 0 &&
      erc20TaxParameters_.maxMetadropSellTaxBasisPoints == 0
    ) {
      return false;
    } else {
      projectBuyTaxBasisPoints = uint16(
        erc20TaxParameters_.projectBuyTaxBasisPoints
      );
      projectSellTaxBasisPoints = uint16(
        erc20TaxParameters_.projectSellTaxBasisPoints
      );
      metadropBuyTaxBasisPoints = uint16(
        erc20TaxParameters_.metadropBuyTaxBasisPoints
      );
      metadropSellTaxBasisPoints = uint16(
        erc20TaxParameters_.metadropSellTaxBasisPoints
      );
      return true;
    }
  }

  /**
   * @dev function {_mintBalances}
   *
   * Mint initial balances
   *
   * @param lpMint_ The number of tokens for liquidity
   * @param projectMint_ The number of tokens for the project treasury
   */
  function _mintBalances(uint256 lpMint_, uint256 projectMint_) internal {
    if (lpMint_ > 0) {
      _mint(address(this), lpMint_);
    }
    if (projectMint_ > 0) {
      _mint(projectTreasury, projectMint_);
    }
  }

  /**
   * @dev function {_createPair}
   *
   * Create the uniswap pair
   *
   * @return uniswapV2Pair_ The pair address
   */
  function _createPair() internal returns (address uniswapV2Pair_) {
    if (_totalSupply > 0) {
      uniswapV2Pair_ = IUniswapV2Factory(uniswapRouter.factory()).createPair(
        address(this),
        uniswapRouter.WETH()
      );

      _liquidityPools.add(uniswapV2Pair_);
      emit LiquidityPoolCreated(uniswapV2Pair_);
    }
    _unlimited.add(address(uniswapRouter));
    _unlimited.add(uniswapV2Pair_);
    return (uniswapV2Pair_);
  }

  /**
   * @dev function {addInitialLiquidity}
   *
   * Add initial liquidity to the uniswap pair
   *
   * @param lockerFee_ The locker fee in wei. This must match the required fee from the external locker contract.
   */
  function addInitialLiquidity(
    uint256 lockerFee_
  ) public payable onlyOwnerOrFactory {
    if (lockerFee_ >= msg.value) {
      // The amount of ETH MUST exceed the locker fee, otherwise what liquidity are we adding?
      _revert(NoETHForLiquidityPair.selector);
    }
    _addInitialLiquidity((msg.value - lockerFee_), lockerFee_);
  }

  /**
   * @dev function {_addInitialLiquidity}
   *
   * Add initial liquidity to the uniswap pair (internal function that does the work)
   *
   * @param ethAmount_ The amount of ETH passed into the call
   * @param lockerFee_ The locker fee in wei. This must match the required fee from the external locker contract.
   */
  function _addInitialLiquidity(
    uint256 ethAmount_,
    uint256 lockerFee_
  ) internal {
    // Funded date is the date of first funding. We can only add initial liquidity once. If this date is set,
    // we cannot proceed
    if (fundedDate == 0) {
      fundedDate = uint32(block.timestamp);
    } else {
      _revert(InitialLiquidityAlreadyAdded.selector);
    }

    // Can only do this if this contract holds tokens:
    if (balanceOf(address(this)) == 0) {
      _revert(NoTokenForLiquidityPair.selector);
    }

    // Approve the uniswap router for an inifinite amount (max uint256)
    // This means that we don't need to worry about later incrememtal
    // approvals on tax swaps, as the uniswap router allowance will never
    // be decreased (see code in decreaseAllowance for reference)
    _approve(address(this), address(uniswapRouter), type(uint256).max);

    // Add the liquidity:
    (uint256 amountA, uint256 amountB, uint256 lpTokens) = uniswapRouter
      .addLiquidityETH{value: ethAmount_}(
      address(this),
      balanceOf(address(this)),
      0,
      0,
      address(this),
      block.timestamp
    );

    emit InitialLiquidityAdded(amountA, amountB, lpTokens);

    autoSwapEnabled = true;
    limitsEnabled = true;

    // Lock the liqidity:
    _lockInitialLiquidity(lockerFee_, lpTokens);
  }

  /**
   * @dev function {_lockInitialLiquidity}
   *
   * Lock initial liquidity on locker contract
   *
   * @param lockerFee_ The locker fee in wei. This must match the required fee from the external locker contract.
   * @param lpTokens_ The amount of LP tokens to be locked
   */
  function _lockInitialLiquidity(
    uint256 lockerFee_,
    uint256 lpTokens_
  ) internal {
    IERC20(uniswapV2Pair).approve(address(unicryptLocker), lpTokens_);

    unicryptLocker.lockLPToken{value: lockerFee_}(
      uniswapV2Pair,
      IERC20(uniswapV2Pair).balanceOf(address(this)),
      block.timestamp + (lpLockupInDays * 1 days),
      payable(address(0)),
      true,
      payable(projectTreasury)
    );

    emit LiquidityLocked();
  }

  /**
   * @dev function {isLiquidityPool}
   *
   * Return if an address is a liquidity pool
   *
   * @param queryAddress_ The address being queried
   * @return bool The address is / isn't a liquidity pool
   */
  function isLiquidityPool(address queryAddress_) public view returns (bool) {
    /** @dev We check the uniswapV2Pair address first as this is an immutable variable and therefore does not need
     * to be fetched from storage, saving gas if this address IS the uniswapV2Pool. We also add this address
     * to the enumerated set for ease of reference (for example it is returned in the getter), and it does
     * not add gas to any other calls, that still complete in 0(1) time.
     */
    return (queryAddress_ == uniswapV2Pair ||
      _liquidityPools.contains(queryAddress_));
  }

  /**
   * @dev function {addLiquidityPool} onlyTaxAdmin
   *
   * Allows the tax admin to add a liquidity pool to the pool enumerable set
   *
   * @param newLiquidityPool_ The address of the new liquidity pool
   */
  function addLiquidityPool(address newLiquidityPool_) public onlyTaxAdmin {
    // Don't allow calls that didn't pass an address:
    if (newLiquidityPool_ == address(0)) {
      _revert(LiquidityPoolCannotBeAddressZero.selector);
    }
    // Only allow smart contract addresses to be added, as only these can be pools:
    if (newLiquidityPool_.code.length == 0) {
      _revert(LiquidityPoolMustBeAContractAddress.selector);
    }
    // Add this to the enumerated list:
    _liquidityPools.add(newLiquidityPool_);
    emit LiquidityPoolAdded(newLiquidityPool_);
  }

  /**
   * @dev function {removeLiquidityPool} onlyTaxAdmin
   *
   * Allows the tax admin to remove a liquidity pool
   *
   * @param removedLiquidityPool_ The address of the old removed liquidity pool
   */
  function removeLiquidityPool(
    address removedLiquidityPool_
  ) public onlyTaxAdmin {
    // Remove this from the enumerated list:
    _liquidityPools.remove(removedLiquidityPool_);
    emit LiquidityPoolRemoved(removedLiquidityPool_);
  }

  /**
   * @dev function {isUnlimited}
   *
   * Return if an address is unlimited (is not subject to per txn and per wallet limits)
   *
   * @param queryAddress_ The address being queried
   * @return bool The address is / isn't unlimited
   */
  function isUnlimited(address queryAddress_) public view returns (bool) {
    return (_unlimited.contains(queryAddress_));
  }

  /**
   * @dev function {addUnlimited} onlyTaxAdmin
   *
   * Allows the tax admin to add an unlimited address
   *
   * @param newUnlimited_ The address of the new unlimited address
   */
  function addUnlimited(address newUnlimited_) public onlyTaxAdmin {
    // Add this to the enumerated list:
    _unlimited.add(newUnlimited_);
    emit UnlimitedAddressAdded(newUnlimited_);
  }

  /**
   * @dev function {removeUnlimited} onlyTaxAdmin
   *
   * Allows the tax admin to remove an unlimited address
   *
   * @param removedUnlimited_ The address of the old removed unlimited address
   */
  function removeUnlimited(address removedUnlimited_) public onlyTaxAdmin {
    // Remove this from the enumerated list:
    _unlimited.remove(removedUnlimited_);
    emit UnlimitedAddressRemoved(removedUnlimited_);
  }

  /**
   * @dev function {setLimitsEnabledStatus} onlyTaxAdmin
   *
   * Allows the tax admin to enable / disable tokens per txn and per holder validation.
   *
   * @param enabled_ Should limits be on?
   */
  function setLimitsEnabledStatus(bool enabled_) public onlyTaxAdmin {
    limitsEnabled = enabled_;
    emit SetLimitsEnabled(enabled_);
  }

  /**
   * @dev function {setProjectTreasury} onlyTaxAdmin
   *
   * Allows the tax admin to set the treasury address
   *
   * @param projectTreasury_ New treasury address
   */
  function setProjectTreasury(address projectTreasury_) public onlyTaxAdmin {
    projectTreasury = projectTreasury_;
    emit TreasuryUpdated(projectTreasury_);
  }

  /**
   * @dev function {setSwapThresholdBasisPoints} onlyTaxAdmin
   *
   * Allows the tax admin to set the autoswap threshold
   *
   * @param swapThresholdBasisPoints_ New swap threshold in basis points
   */
  function setSwapThresholdBasisPoints(
    uint16 swapThresholdBasisPoints_
  ) public onlyTaxAdmin {
    uint256 oldswapThresholdBasisPoints = swapThresholdBasisPoints;
    swapThresholdBasisPoints = swapThresholdBasisPoints_;
    emit AutoSwapThresholdUpdated(
      oldswapThresholdBasisPoints,
      swapThresholdBasisPoints_
    );
  }

  /**
   * @dev function {withdrawETH} onlyOwner
   *
   * Allows the owner to withdraw ETH
   *
   * @param amount_ The amount to withdraw
   */
  function withdrawETH(uint256 amount_) external onlyOwner {
    (bool success, ) = owner().call{value: amount_}("");
    if (!success) {
      _revert(TransferFailed.selector);
    }
  }

  /**
   * @dev function {withdrawERC20} onlyOwner
   *
   * A withdraw function to allow ERC20s to be withdrawn.
   *
   * @param token_ The address of the token being withdrawn
   * @param amount_ The amount to withdraw
   */
  function withdrawERC20(IERC20 token_, uint256 amount_) external onlyOwner {
    token_.safeTransfer(owner(), amount_);
  }

  /**
   * @dev function {setProjectTaxRates} onlyTaxAdmin
   *
   * Change the tax rates, subject to max rate
   *
   * @param newProjectBuyTaxBasisPoints_ The new buy tax rate
   * @param newProjectSellTaxBasisPoints_ The new sell tax rate
   */
  function setProjectTaxRates(
    uint16 newProjectBuyTaxBasisPoints_,
    uint16 newProjectSellTaxBasisPoints_
  ) external onlyTaxAdmin {
    // Cannot increase above the maximum:
    if (newProjectBuyTaxBasisPoints_ > maxProjectBuyTaxBasisPoints) {
      _revert(NewBuyTaxBasisPointsExceedsMaximum.selector);
    }
    // Cannot increase above the maximum:
    if (newProjectSellTaxBasisPoints_ > maxProjectSellTaxBasisPoints) {
      _revert(NewSellTaxBasisPointsExceedsMaximum.selector);
    }

    uint16 oldBuyTaxBasisPoints = projectBuyTaxBasisPoints;
    projectBuyTaxBasisPoints = newProjectBuyTaxBasisPoints_;

    uint16 oldSellTaxBasisPoints = projectSellTaxBasisPoints;
    projectSellTaxBasisPoints = newProjectSellTaxBasisPoints_;

    emit ProjectTaxBasisPointsChanged(
      oldBuyTaxBasisPoints,
      newProjectBuyTaxBasisPoints_,
      oldSellTaxBasisPoints,
      newProjectSellTaxBasisPoints_
    );
  }

  /**
   * @dev function {setMetadropTaxRates} onlyTaxAdmin
   *
   * Change the tax rates, subject to max rate and minimum tax period.
   *
   * @param newMetadropBuyTaxBasisPoints_ The new buy tax rate
   * @param newMetadropSellTaxBasisPoints_ The new sell tax rate
   */
  function setMetadropTaxRates(
    uint16 newMetadropBuyTaxBasisPoints_,
    uint16 newMetadropSellTaxBasisPoints_
  ) external onlyTaxAdmin {
    // Cannot increase above the maximum:
    if (newMetadropBuyTaxBasisPoints_ > maxMetadropBuyTaxBasisPoints) {
      _revert(NewBuyTaxBasisPointsExceedsMaximum.selector);
    }

    // Cannot increase above the maximum:
    if (newMetadropSellTaxBasisPoints_ > maxMetadropSellTaxBasisPoints) {
      _revert(NewSellTaxBasisPointsExceedsMaximum.selector);
    }

    // Reducing the basis points can only occur after the tax period:
    if (
      (newMetadropBuyTaxBasisPoints_ < metadropBuyTaxBasisPoints ||
        newMetadropSellTaxBasisPoints_ < metadropSellTaxBasisPoints) &&
      block.timestamp < (fundedDate + (metadropTaxPeriodInDays * 1 days))
    ) {
      _revert(TaxPeriodStillInForce.selector);
    }

    uint16 oldBuyTaxBasisPoints = metadropBuyTaxBasisPoints;
    uint16 oldSellTaxBasisPoints = metadropSellTaxBasisPoints;

    metadropBuyTaxBasisPoints = newMetadropBuyTaxBasisPoints_;
    metadropSellTaxBasisPoints = newMetadropSellTaxBasisPoints_;

    emit MetadropTaxBasisPointsChanged(
      oldBuyTaxBasisPoints,
      newMetadropBuyTaxBasisPoints_,
      oldSellTaxBasisPoints,
      newMetadropSellTaxBasisPoints_
    );
  }

  /**
   * @dev Returns the name of the token.
   */
  function name() public view virtual override returns (string memory) {
    return _name;
  }

  /**
   * @dev Returns the symbol of the token, usually a shorter version of the
   * name.
   */
  function symbol() public view virtual override returns (string memory) {
    return _symbol;
  }

  /**
   * @dev Returns the number of decimals used to get its user representation.
   * For example, if `decimals` equals `2`, a balance of `505` tokens should
   * be displayed to a user as `5.05` (`505 / 10 ** 2`).
   *
   * Tokens usually opt for a value of 18, imitating the relationship between
   * Ether and Wei. This is the default value returned by this function, unless
   * it's overridden.
   *
   * NOTE: This information is only used for _display_ purposes: it in
   * no way affects any of the arithmetic of the contract, including
   * {IERC20-balanceOf} and {IERC20-transfer}.
   */
  function decimals() public view virtual override returns (uint8) {
    return 18;
  }

  /**
   * @dev See {IERC20-totalSupply}.
   */
  function totalSupply() public view virtual override returns (uint256) {
    return _totalSupply;
  }

  /**
   * @dev Provide easy to view tax total:
   */
  function _totalBuyTaxBasisPoints() internal view returns (uint256) {
    return projectBuyTaxBasisPoints + metadropBuyTaxBasisPoints;
  }

  /**
   * @dev Provide easy to view tax total:
   */
  function _totalSellTaxBasisPoints() internal view returns (uint256) {
    return projectSellTaxBasisPoints + metadropSellTaxBasisPoints;
  }

  /**
   * @dev See {IERC20-balanceOf}.
   */
  function balanceOf(
    address account
  ) public view virtual override returns (uint256) {
    return _balances[account];
  }

  /**
   * @dev See {IERC20-transfer}.
   *
   * Requirements:
   *
   * - `to` cannot be the zero address.
   * - the caller must have a balance of at least `amount`.
   */
  function transfer(
    address to,
    uint256 amount
  ) public virtual override(ERC20Spendable, IERC20) returns (bool) {
    address owner = _msgSender();
    _transfer(
      owner,
      to,
      amount,
      (isLiquidityPool(owner) || isLiquidityPool(to))
    );
    return true;
  }

  /**
   * @dev See {IERC20-allowance}.
   */
  function allowance(
    address owner,
    address spender
  ) public view virtual override returns (uint256) {
    return _allowances[owner][spender];
  }

  /**
   * @dev See {IERC20-approve}.
   *
   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
   * `transferFrom`. This is semantically equivalent to an infinite approval.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function approve(
    address spender,
    uint256 amount
  ) public virtual override returns (bool) {
    address owner = _msgSender();
    _approve(owner, spender, amount);
    return true;
  }

  /**
   * @dev See {IERC20-transferFrom}.
   *
   * Emits an {Approval} event indicating the updated allowance. This is not
   * required by the EIP. See the note at the beginning of {ERC20}.
   *
   * NOTE: Does not update the allowance if the current allowance
   * is the maximum `uint256`.
   *
   * Requirements:
   *
   * - `from` and `to` cannot be the zero address.
   * - `from` must have a balance of at least `amount`.
   * - the caller must have allowance for ``from``'s tokens of at least
   * `amount`.
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public virtual override returns (bool) {
    address spender = _msgSender();
    _spendAllowance(from, spender, amount);
    _transfer(from, to, amount, (isLiquidityPool(from) || isLiquidityPool(to)));
    return true;
  }

  /**
   * @dev Atomically increases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to {approve} that can be used as a mitigation for
   * problems described in {IERC20-approve}.
   *
   * Emits an {Approval} event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   */
  function increaseAllowance(
    address spender,
    uint256 addedValue
  ) public virtual returns (bool) {
    address owner = _msgSender();
    _approve(owner, spender, allowance(owner, spender) + addedValue);
    return true;
  }

  /**
   * @dev Atomically decreases the allowance granted to `spender` by the caller.
   *
   * This is an alternative to {approve} that can be used as a mitigation for
   * problems described in {IERC20-approve}.
   *
   * Emits an {Approval} event indicating the updated allowance.
   *
   * Requirements:
   *
   * - `spender` cannot be the zero address.
   * - `spender` must have allowance for the caller of at least
   * `subtractedValue`.
   */
  function decreaseAllowance(
    address spender,
    uint256 subtractedValue
  ) public virtual returns (bool) {
    address owner = _msgSender();
    uint256 currentAllowance = allowance(owner, spender);
    if (currentAllowance < subtractedValue) {
      _revert(AllowanceDecreasedBelowZero.selector);
    }
    unchecked {
      _approve(owner, spender, currentAllowance - subtractedValue);
    }

    return true;
  }

  /**
   * @dev Moves `amount` of tokens from `from` to `to`.
   *
   * This internal function is equivalent to {transfer}, and can be used to
   * e.g. implement automatic token fees, slashing mechanisms, etc.
   *
   * Emits a {Transfer} event.
   *
   * Requirements:
   *
   * - `from` cannot be the zero address.
   * - `to` cannot be the zero address.
   * - `from` must have a balance of at least `amount`.
   */
  function _transfer(
    address from,
    address to,
    uint256 amount,
    bool applyTax
  ) internal virtual {
    _beforeTokenTransfer(from, to, amount);

    // Perform pre-tax validation (e.g. amount doesn't exceed balance, max txn amount)
    uint256 fromBalance = _pretaxValidationAndLimits(from, to, amount);

    // Perform autoswap if eligible
    _autoSwap(from, to);

    // Process taxes
    uint256 amountMinusTax = _taxProcessing(applyTax, to, from, amount);

    // Perform post-tax validation (e.g. total balance after post-tax amount applied)
    _posttaxValidationAndLimits(to, amountMinusTax);

    _balances[from] = fromBalance - amount;
    _balances[to] += amountMinusTax;

    emit Transfer(from, to, amountMinusTax);

    _afterTokenTransfer(from, to, amount);
  }

  /**
   * @dev function {_pretaxValidationAndLimits}
   *
   * Perform validation on pre-tax amounts
   *
   * @param from_ From address for the transaction
   * @param to_ To address for the transaction
   * @param amount_ Amount of the transaction
   */
  function _pretaxValidationAndLimits(
    address from_,
    address to_,
    uint256 amount_
  ) internal view returns (uint256 fromBalance_) {
    if (from_ == address(0)) {
      _revert(TransferFromZeroAddress.selector);
    }

    if (to_ == address(0)) {
      _revert(TransferToZeroAddress.selector);
    }

    fromBalance_ = _balances[from_];

    if (fromBalance_ < amount_) {
      _revert(TransferAmountExceedsBalance.selector);
    }

    // Liquidity pools aren't always going to round cleanly. This can (and does)
    // mean that a limit of 5,000 tokens (for example) will trigger on a transfer
    // of 5,000 tokens, as the transfer is actually for 5,000.00000000000000213.
    // While 4,999 will work fine, it isn't hugely user friendly. So we buffer
    // the limit with rounding decimals, which in all cases are considerably less
    // than one whole token:
    uint256 roundedLimited;

    unchecked {
      roundedLimited = maxTokensPerTransaction + ROUND_DEC;
    }

    if (
      tokenHasLimits &&
      limitsEnabled &&
      (maxTokensPerTransaction != 0) &&
      (amount_ > roundedLimited) &&
      ((isLiquidityPool(from_) && !isUnlimited(to_)) ||
        (isLiquidityPool(to_) && !isUnlimited(from_)))
    ) {
      _revert(MaxTokensPerTxnExceeded.selector);
    }

    return (fromBalance_);
  }

  /**
   * @dev function {_posttaxValidationAndLimits}
   *
   * Perform validation on post-tax amounts
   *
   * @param to_ To address for the transaction
   * @param amount_ Amount of the transaction
   */
  function _posttaxValidationAndLimits(
    address to_,
    uint256 amount_
  ) internal view returns (uint256 fromBalance_) {
    // Liquidity pools aren't always going to round cleanly. This can (and does)
    // mean that a limit of 5,000 tokens (for example) will trigger on a max holding
    // of 5,000 tokens, as the transfer to achieve that is actually for
    // 5,000.00000000000000213. While 4,999 will work fine, it isn't hugely user friendly.
    // So we buffer the limit with rounding decimals, which in all cases are considerably
    // less than one whole token:
    uint256 roundedLimited;

    unchecked {
      roundedLimited = maxTokensPerWallet + ROUND_DEC;
    }
    if (
      tokenHasLimits &&
      limitsEnabled &&
      (maxTokensPerWallet != 0) &&
      (amount_ + balanceOf(to_) > roundedLimited) &&
      !isUnlimited(to_) &&
      !isLiquidityPool(to_)
    ) {
      _revert(MaxTokensPerWalletExceeded.selector);
    }

    return (fromBalance_);
  }

  /**
   * @dev function {_taxProcessing}
   *
   * Perform tax processing
   *
   * @param applyTax_ Do we apply tax to this transaction?
   * @param to_ The reciever of the token
   * @param from_ The sender of the token
   * @param sentAmount_ The amount being send
   * @return amountLessTax_ The amount that will be recieved, i.e. the send amount minus tax
   */
  function _taxProcessing(
    bool applyTax_,
    address to_,
    address from_,
    uint256 sentAmount_
  ) internal returns (uint256 amountLessTax_) {
    if (to_ == address(uniswapRouter) || from_ == address(uniswapRouter)) {
      return (sentAmount_);
    }
    amountLessTax_ = sentAmount_;
    unchecked {
      if (tokenHasTax && applyTax_ && autoSwapEnabled) {
        uint256 tax;

        // on sell
        if (isLiquidityPool(to_) && _totalSellTaxBasisPoints() > 0) {
          if (projectSellTaxBasisPoints > 0) {
            uint256 projectTax = ((sentAmount_ * projectSellTaxBasisPoints) /
              BP_DENOM);
            projectTaxPendingSwap += uint128(projectTax);
            tax += projectTax;
          }
          if (metadropSellTaxBasisPoints > 0) {
            uint256 metadropTax = ((sentAmount_ * metadropSellTaxBasisPoints) /
              BP_DENOM);
            metadropTaxPendingSwap += uint128(metadropTax);
            tax += metadropTax;
          }
        }
        // on buy
        else if (isLiquidityPool(from_) && _totalBuyTaxBasisPoints() > 0) {
          if (projectBuyTaxBasisPoints > 0) {
            uint256 projectTax = ((sentAmount_ * projectBuyTaxBasisPoints) /
              BP_DENOM);
            projectTaxPendingSwap += uint128(projectTax);
            tax += projectTax;
          }
          if (metadropBuyTaxBasisPoints > 0) {
            uint256 metadropTax = ((sentAmount_ * metadropBuyTaxBasisPoints) /
              BP_DENOM);
            metadropTaxPendingSwap += uint128(metadropTax);
            tax += metadropTax;
          }
        }

        if (tax > 0) {
          _balances[address(this)] += tax;
          emit Transfer(from_, address(this), tax);
          amountLessTax_ -= tax;
        }
      }
    }
    return (amountLessTax_);
  }

  /**
   * @dev function {_autoSwap}
   *
   * Automate the swap of accumulated tax fees to native token
   *
   * @param from_ The sender of the token
   */
  function _autoSwap(address from_, address to_) internal {
    if (tokenHasTax) {
      uint256 taxBalance = balanceOf(address(this));

      if (_eligibleForSwap(from_, to_, taxBalance)) {
        // Store that a swap back is in progress:
        autoSwapEnabled = false;
        // Perform the auto swap to native token:
        _swapTaxForNative(taxBalance);
        // Flag that the autoswap is complete:
        autoSwapEnabled = true;
      }
    }
  }

  /**
   * @dev function {_eligibleForSwap}
   *
   * Is the current transfer eligible for autoswap
   *
   * @param from_ The sender of the token
   * @param taxBalance_ The current accumulated tax balance
   */
  function _eligibleForSwap(
    address from_,
    address to_,
    uint256 taxBalance_
  ) internal view returns (bool) {
    return (taxBalance_ >=
      ((_totalSupply * swapThresholdBasisPoints) / BP_DENOM) &&
      autoSwapEnabled &&
      !isLiquidityPool(from_) &&
      from_ != address(uniswapRouter) &&
      to_ != address(uniswapRouter));
  }

  /**
   * @dev function {_swapTaxForNative}
   *
   * Swap tokens taken as tax for native token
   *
   * @param taxBalance_ The current accumulated tax balance
   */
  function _swapTaxForNative(uint256 taxBalance_) internal {
    uint256 preSwapBalance = address(this).balance;

    address[] memory path = new address[](2);
    path[0] = address(this);
    path[1] = uniswapRouter.WETH();

    uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
      taxBalance_,
      0,
      path,
      address(this),
      block.timestamp
    );

    uint256 postSwapBalance = address(this).balance;

    uint256 balanceToDistribute = postSwapBalance - preSwapBalance;

    uint256 projectBalanceToDistribute = (balanceToDistribute *
      projectTaxPendingSwap) / (projectTaxPendingSwap + metadropTaxPendingSwap);

    uint256 metadropBalanceToDistribute = (balanceToDistribute *
      metadropTaxPendingSwap) /
      (projectTaxPendingSwap + metadropTaxPendingSwap);

    (projectTaxPendingSwap, metadropTaxPendingSwap) = (0, 0);

    // Distribute to treasuries:
    bool success;
    (success, ) = projectTreasury.call{value: projectBalanceToDistribute}("");
    if (!success) {
      _revert(TransferFailed.selector);
    }

    (success, ) = metadropTreasury.call{value: metadropBalanceToDistribute}("");
    if (!success) {
      _revert(TransferFailed.selector);
    }
  }

  /** @dev Creates `amount` tokens and assigns them to `account`, increasing
   * the total supply.
   *
   * Emits a {Transfer} event with `from` set to the zero address.
   *
   * Requirements:
   *
   * - `account` cannot be the zero address.
   */
  function _mint(address account, uint256 amount) internal virtual {
    if (account == address(0)) {
      _revert(MintToZeroAddress.selector);
    }

    _beforeTokenTransfer(address(0), account, amount);

    _totalSupply += amount;
    unchecked {
      // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
      _balances[account] += amount;
    }
    emit Transfer(address(0), account, amount);

    _afterTokenTransfer(address(0), account, amount);
  }

  /**
   * @dev Destroys `amount` tokens from `account`, reducing the
   * total supply.
   *
   * Emits a {Transfer} event with `to` set to the zero address.
   *
   * Requirements:
   *
   * - `account` cannot be the zero address.
   * - `account` must have at least `amount` tokens.
   */
  function _burn(address account, uint256 amount) internal virtual {
    if (account == address(0)) {
      _revert(BurnFromTheZeroAddress.selector);
    }

    _beforeTokenTransfer(account, address(0), amount);

    uint256 accountBalance = _balances[account];
    if (accountBalance < amount) {
      _revert(BurnExceedsBalance.selector);
    }

    unchecked {
      _balances[account] = accountBalance - amount;
      // Overflow not possible: amount <= accountBalance <= totalSupply.
      _totalSupply -= amount;
    }

    emit Transfer(account, address(0), amount);

    _afterTokenTransfer(account, address(0), amount);
  }

  /**
   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
   *
   * This internal function is equivalent to `approve`, and can be used to
   * e.g. set automatic allowances for certain subsystems, etc.
   *
   * Emits an {Approval} event.
   *
   * Requirements:
   *
   * - `owner` cannot be the zero address.
   * - `spender` cannot be the zero address.
   */
  function _approve(
    address owner,
    address spender,
    uint256 amount
  ) internal virtual {
    if (owner == address(0)) {
      _revert(ApproveFromTheZeroAddress.selector);
    }

    if (spender == address(0)) {
      _revert(ApproveToTheZeroAddress.selector);
    }

    _allowances[owner][spender] = amount;
    emit Approval(owner, spender, amount);
  }

  /**
   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
   *
   * Does not update the allowance amount in case of infinite allowance.
   * Revert if not enough allowance is available.
   *
   * Might emit an {Approval} event.
   */
  function _spendAllowance(
    address owner,
    address spender,
    uint256 amount
  ) internal virtual {
    uint256 currentAllowance = allowance(owner, spender);
    if (currentAllowance != type(uint256).max) {
      if (currentAllowance < amount) {
        _revert(InsufficientAllowance.selector);
      }

      unchecked {
        _approve(owner, spender, currentAllowance - amount);
      }
    }
  }

  /**
   * @dev Destroys a `value` amount of tokens from the caller.
   *
   * See {ERC20-_burn}.
   */
  function burn(uint256 value) public virtual {
    _burn(_msgSender(), value);
  }

  /**
   * @dev Destroys a `value` amount of tokens from `account`, deducting from
   * the caller's allowance.
   *
   * See {ERC20-_burn} and {ERC20-allowance}.
   *
   * Requirements:
   *
   * - the caller must have allowance for ``accounts``'s tokens of at least
   * `value`.
   */
  function burnFrom(address account, uint256 value) public virtual {
    _spendAllowance(account, _msgSender(), value);
    _burn(account, value);
  }

  /**
   * @dev Hook that is called before any transfer of tokens. This includes
   * minting and burning.
   *
   * Calling conditions:
   *
   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
   * will be transferred to `to`.
   * - when `from` is zero, `amount` tokens will be minted for `to`.
   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
   * - `from` and `to` are never both zero.
   *
   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
   */
  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 amount
  ) internal virtual {}

  /**
   * @dev Hook that is called after any transfer of tokens. This includes
   * minting and burning.
   *
   * Calling conditions:
   *
   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
   * has been transferred to `to`.
   * - when `from` is zero, `amount` tokens have been minted for `to`.
   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
   * - `from` and `to` are never both zero.
   *
   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
   */
  function _afterTokenTransfer(
    address from,
    address to,
    uint256 amount
  ) internal virtual {}

  receive() external payable {}
}
