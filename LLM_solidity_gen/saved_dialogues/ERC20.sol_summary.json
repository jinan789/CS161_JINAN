[{"role": "user", "content": "I will give you solidity contracts, and I want you to give me a summary of each function that is contained in the contract. Write your answer in the form of bullet points. Make sure to start each bullet point with the function signature that you are summarizing, and follow it with the summary. For the last bullet point, please give me a summary of the functions in the previous bullet points as a summary of the entire contract. \n\nHere is an example of the sample output, starting with the <START> token and ending with the <END> token:\n<START>\n- constructor(string memory _name, string memory _symbol, uint8 _decimals): Initializes the ERC20 contract with a name, symbol and decimals count.\n- approve(address spender, uint256 amount) public virtual returns (bool): Approves the `spender` to spend `amount` of tokens on behalf of the caller.\n- transfer(address to, uint256 amount) public virtual returns (bool): Transfers `amount` of tokens from the caller to the `to` address.\n- transferFrom(address from, address to, uint256 amount) public virtual returns (bool): Transfers `amount` of tokens from address `from` to address `to`. Requires approval of the caller by the `from` address.\n\nSummary of the entire contract:\nThe ERC20 contract implementation provides basic functionality for a token, including transferring tokens, approving a spender, and manipulating allowances. It also implements EIP-2612 to allow for off-chain approvals via permit(). The contract provides internal minting and burning functions for managing token supply. The domain separator functions help prevent replay attacks across different chains.\n<END>\n\nHere are the codes: // SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"}, {"role": "system", "content": "<START>\n- constructor(string memory _name, string memory _symbol, uint8 _decimals): Initializes the ERC20 contract with a name, symbol, and decimals count.\n- approve(address spender, uint256 amount) public virtual returns (bool): Approves the `spender` to spend `amount` of tokens on behalf of the caller.\n- transfer(address to, uint256 amount) public virtual returns (bool): Transfers `amount` of tokens from the caller to the `to` address.\n- transferFrom(address from, address to, uint256 amount) public virtual returns (bool): Transfers `amount` of tokens from address `from` to address `to`. Requires approval of the caller by the `from` address.\n- permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual: Allows off-chain approvals, as described in EIP-2612, and sets `spender`'s allowance for caller's tokens to be `value.`\n- DOMAIN_SEPARATOR() public view virtual returns (bytes32): Returns the domain separator for EIP-712 signature replay protection, recomputing it if the chain ID has changed.\n- computeDomainSeparator() internal view virtual returns (bytes32): Computes the EIP-712 domain separator for the contract.\n- _mint(address to, uint256 amount) internal virtual: Mints `amount` of tokens to the `to` address.\n- _burn(address from, uint256 amount) internal virtual: Burns `amount` of tokens from the `from` address.\n\nSummary of the entire contract:\nThe ERC20 contract implementation provides basic token functionality, including transferring tokens, approving a spender, and manipulating allowances. It also implements EIP-2612 for off-chain approvals using the `permit()` function. The contract provides internal minting and burning methods to manage token supply. Domain separator functions are included to offer EIP-712 signature replay protection across different chains.\n<END>"}]