
The function that I want you to summarize is seizeInternal, which is defined in the codes given below. Please note that I have hidden the definition of all other functions, but I still kept their signature, with the purpose of providing richer background information for you. The codes are: 
pragma solidity ^0.5.16;

import "./ComptrollerInterface.sol";
import "./CTokenInterfaces.sol";
import "./ErrorReporter.sol";
import "./Exponential.sol";
import "./EIP20Interface.sol";
import "./InterestRateModel.sol";

/**
 * @title Compound's CToken Contract
 * @notice Abstract base for CTokens
 * @author Compound
 */
contract CToken is CTokenInterface, Exponential, TokenErrorReporter {
    /**
     * @notice Initialize the money market
     * @param comptroller_ The address of the Comptroller
     * @param interestRateModel_ The address of the interest rate model
     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    function initialize(ComptrollerInterface comptroller_,
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
    function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {
    function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {
    function approve(address spender, uint256 amount) external returns (bool) {
    function allowance(address owner, address spender) external view returns (uint256) {
    function balanceOf(address owner) external view returns (uint256) {
    function balanceOfUnderlying(address owner) external returns (uint) {
    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {
    function getBlockNumber() internal view returns (uint) {
    function borrowRatePerBlock() external view returns (uint) {
    function supplyRatePerBlock() external view returns (uint) {
    function totalBorrowsCurrent() external nonReentrant returns (uint) {
    function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {
    function borrowBalanceStored(address account) public view returns (uint) {
    function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint) {
    function exchangeRateCurrent() public nonReentrant returns (uint) {
    function exchangeRateStored() public view returns (uint) {
    function exchangeRateStoredInternal() internal view returns (MathError, uint) {
    function getCash() external view returns (uint) {
    function accrueInterest() public returns (uint) {
    function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {
    function mintFresh(address minter, uint mintAmount) internal returns (uint, uint) {
    function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {
    function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {
    function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint) {
    function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {
    function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {
    function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {
    function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {
    function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {
    function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant returns (uint, uint) {
    function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal returns (uint, uint) {
    function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {
    function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint) {
        /* Fail if seize not allowed */
        uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);
        if (allowed != 0) {
            return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);
        }

        /* Fail if borrower = liquidator */
        if (borrower == liquidator) {
            return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);
        }

        SeizeInternalLocalVars memory vars;

        /*
         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:
         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens
         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens
         */
        (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint(vars.mathErr));
        }

        vars.protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa: protocolSeizeShareMantissa}));
        vars.liquidatorSeizeTokens = sub_(seizeTokens, vars.protocolSeizeTokens);

        (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();
        require(vars.mathErr == MathError.NO_ERROR, "exchange rate math error");

        vars.protocolSeizeAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), vars.protocolSeizeTokens);

        vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);
        vars.totalSupplyNew = sub_(totalSupply, vars.protocolSeizeTokens);

        (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);
        if (vars.mathErr != MathError.NO_ERROR) {
            return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint(vars.mathErr));
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /* We write the previously calculated values into storage */
        totalReserves = vars.totalReservesNew;
        totalSupply = vars.totalSupplyNew;
        accountTokens[borrower] = vars.borrowerTokensNew;
        accountTokens[liquidator] = vars.liquidatorTokensNew;

        /* Emit a Transfer event */
        emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);
        emit Transfer(borrower, address(this), vars.protocolSeizeTokens);
        emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);

        /* We call the defense hook */
        // unused function
        // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);

        return uint(Error.NO_ERROR);
    }


    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {
    function _acceptAdmin() external returns (uint) {
    function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {
    function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {
    function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {
    function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {
    function _addReservesFresh(uint addAmount) internal returns (uint, uint) {
    function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {
    function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {
    function getCashPrior() internal view returns (uint);
    function doTransferIn(address from, uint amount) internal returns (uint);
    function doTransferOut(address payable to, uint amount) internal;
}
